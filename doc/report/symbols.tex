A symbol represent the address of either a function or a variable. Retrieving
a symbol is the first step into modifying data.
A symbol is just a name associated to an address.
Symbols are primarly designed for debugging purposes. Many distributions
enable them because the kernel can print out symbolic crash or stack
information.
Depending on the configuration of your kernel, differents methods are available.

\subsection{Kallsyms}
The Kconfig \ubox{CONFIG\_KALLSYMS} allows the symbols exported with the macros
\cmd{EXPORT\_SYMBOL} and \cmd{EXPORT\_SYMBOL\_GPL} to be loaded into the kernel
image.
Kallsyms are dynamically exported by the kernel via \cmd{/proc/kallsyms }.
You can simply \cmd{cat} this file to get all the symbols addresses:\\
\begin{bashcode}
$ cat /proc/kallsyms| grep " printk$"
ffffffff81536ed7 T printk
\end{bashcode}

When writing kernel code, you can use the function:\\
\begin{ccode}
/* Lookup the address for this symbol. Returns 0 if not found. */
unsigned long kallsyms_lookup_name(const char *name);
\end{ccode}

This function is a simple way to retrieve an address but it depends on
\ubox{CONFIG\_KALLSYMS} and not all symbols are exported. For example you
can't retrieve the address of a global variable.

If your kernel has been compiled with \ubox{CONFIG\_KALLSYMS\_ALL}, you can
retrieve all the symbols of the kernel, but this option is not commonly
activated because it takes a lot of additional space in the kernel image
to store them.

\subsection{System.map}
System.map is also a simple file thaht contains the list of symbols and their
addresses. This file is generated with each kernel compile. This mean that a
System.map file only works with the kernel that generated it.
The file is often stored at: \texttt{/boot/System.map} or \texttt{/System.map}.
\\
\begin{bashcode}
$ cat /boot/System.map | grep " printk$"
ffffffff81536ed7 T printk
\end{bashcode}

\subsection{Patterns}
Searching a symbol with a pattern is basically what the \cmd{grep} command
does. In our case, we are dealing with opcode and numbers, but the principe
remains the same: we iter through a section of code (or data) and look for
a specific sequence of instructions (context) to extract the data we want.
Since the problem is to search for a pattern within an array of byte, we can
use the Knuth–Morris–Pratt algorithm to get a $\Theta(n)$ search.

Iterating through the entire Linux image can be long and hazardous, so we need
to shorten the range. An efficient way of doing this is to first retrieve the
beginning and the end of each section of the linux image, so that we can just
iter through the \ubox{.text} section if we search for function symbol.


Let's take an example, the \ubox{syscall\_table} symbol which is an array of
function pointer that refers to the syscalls (entry 4 will be the syscall
number 4).
We know that this symbol is being used in the syscall handler because it needs
to call the appropriate function when a syscall is issued.
The disassembly of the syscall handler is the following:\\
\begin{bashcode}
$ gdb -batch -ex 'file ./vmlinux' -ex 'disassemble system_call_fastpath'}
Dump of assembler code for function system_call_fastpath:
   0xffffffff81872040 <+0>: cmp    $0x142,%rax
   0xffffffff81872046 <+6>: ja     0xffffffff81872057 <ret_from_sys_call>
   0xffffffff81872048 <+8>: mov    %r10,%rcx
   0xffffffff8187204b <+11>:    callq  *-0x7e5ffd40(,%rax,8)
   0xffffffff81872052 <+18>:    mov    %rax,0x20(%rsp)
End of assembler dump.
\end{bashcode}

The interesting part of this dump is \cmd{callq  *-0x7e5ffd40(,\%rax,8)}
because it contains the address of the symbol we are looking for.
To extract it, we create a pattern from the context of this line using the
hexadecimal representation of the code. We need to skip everything related to
addresses because it may varies.\\

We obtain the following pattern:\\
\begin{ccode}
{
    .name = "sys_call_table",
        .asm_pattern = {
            .pattern   = {                          // <system_call_fastpath>:
                0x48, 0x3d, 0x3c, 0x01, 0x00, 0x00,         // cmp    $0x142,%rax
                0x0f, 0x87, SKIP, SKIP, SKIP, SKIP,         // ja     <...>
                0x4c, 0x89, 0xd1,                           // mov    %r10,%rcx
                0xff, 0x14, 0xc5, SAVE, SAVE, SAVE, SAVE,   // callq  *0x0(,%rax,8)
                0x48, 0x89, 0x44, 0x24, 0x20,               // mov    %rax,0x20(%rsp)
                END,
            },
            .start     = _text,    // beginning of .text section
            .end       = _etext,   // end of .text section
        },
},
\end{ccode}%$

The advantage of such a search is that we do not explicitly rely on particular
Linux configuration like \ubox{CONFIG\_KALLSYMS} nor an external file. The
drawback is that the pattern may change depending on the Linux version or the
configuration. The kernel part that handle syscall is unlikely to change or
generate different code due to some configuration so we can assume that this
method works well for this kind of symbols.
